from pathlib import Path
import ast
import datetime
import os, sys

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(sys.executable), "../..")))
from utils.code_generator.base_commander_template import SCRIPT_HEADER, CLASS_INIT, SEND_COMMAND_METHOD

OUTPUT_DIR = "./gerri/utils/commander_builder/output/"
BACKUP_DIR = "./gerri/utils/commander_builder/backup/"
ROBOT_NAME = "default_robot"

def backup_file(file_path: str):
    path = Path(file_path)
    file_name = os.path.splitext(os.path.basename(file_path))[0]
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = Path(BACKUP_DIR) / f"{file_name}-{timestamp}.py"
    path.rename(backup_path)
    print(f"Backup created: {backup_path}")

def make_commander_method(funcs, output_path):
    for func_name, func_info in funcs.items():
        params = func_info["params"]
        with open(output_path, "a", encoding="utf-8") as f:
            f.write(f"\n    def {func_name}(self")

            # 파라미터 작성
            for param, attr in params.items():
                if "default" in attr:
                    default_value = repr(attr["default"])
                    f.write(f", {param}={default_value}")
                else:
                    f.write(f", {param}")

            f.write("):\n")
            f.write(f'        topic = "{func_name}"\n')
            f.write(f'        value = {{}}\n')
            for param in params.keys():
                f.write(f'        value["{param}"] = {param}\n')
            f.write(f'        self.send_command(topic=topic, value=value)\n')

def extract_functions(file_path: str):
    path = Path(file_path)
    source = path.read_text(encoding="utf-8")
    tree = ast.parse(source)

    functions = {}

    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            func_name = node.name

            # 내부용 함수(_로 시작)는 스킵
            if func_name.startswith("_"):
                continue

            params = {}
            for arg in node.args.args:
                if arg.arg == "self":
                    continue
                params[arg.arg] = {}

            defaults = node.args.defaults
            if defaults:
                offset = len(params) - len(defaults)
                for i, default in enumerate(defaults):
                    arg_name = list(params.keys())[i + offset]
                    try:
                        value = ast.literal_eval(default)
                    except Exception:
                        value = None
                    params[arg_name]["default"] = value

            functions[func_name] = {
                "params": params,
                "docstring": ast.get_docstring(node) or ""
            }

    return functions

def build_robot_commander(robot_interface_path, robot_name, output_path: str) -> None:

    if os.path.exists(output_path):
        backup_file(output_path)
        
    with open(output_path, "w", encoding="utf-8") as f:
        f.write('"""\nThis file is auto-generated by robot_commander_builder.py\nYou should move this file to the gerri/operator/your_robot_directory\n"""\n\n')
        f.write(SCRIPT_HEADER)
        f.write(f"class {robot_name}Commander:\n")
        f.write(CLASS_INIT)
        f.write(SEND_COMMAND_METHOD)

    print(extract_functions(robot_interface_path))

###################################################################
def _add_parent_links(node):
    for child in ast.iter_child_nodes(node):
        child.parent = node
        _add_parent_links(child)

def detect_robot_interface_type(file_path: str) -> str:
    path = Path(file_path)
    if not path.exists():
        raise FileNotFoundError(f"File not found: {file_path}")

    source = path.read_text(encoding="utf-8")
    tree = ast.parse(source)
    _add_parent_links(tree)

    has_class = False
    has_function = False

    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            has_class = True
        elif isinstance(node, ast.FunctionDef):
            # 최상위 함수만 체크
            if isinstance(node.parent, ast.Module):
                has_function = True

    if has_class and has_function:
        return "mixed"
    elif has_class:
        return "class"
    elif has_function:
        return "function"
    else:
        return "unknown"
###################################################################


def main(robot_interface_file_path, robot_name, output_path):
    path = Path(robot_interface_file_path)

    print(f"Target file: {path.resolve()}")
    build_robot_commander(path.resolve(), robot_name, output_path)
    functions = extract_functions(path.resolve())
    make_commander_method(functions, output_path)

if __name__ == "__main__":
    main()