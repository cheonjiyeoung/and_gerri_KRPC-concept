from pathlib import Path
import ast
from robot_commander_template import SCRIPT_HEADER, CLASS_INIT, SEND_COMMAND_METHOD
import datetime
import os, sys

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(sys.executable), "../..")))

OUTPUT_DIR = "./gerri/utils/commander_builder/output/"
BACKUP_DIR = "./gerri/utils/commander_builder/backup/"
ROBOT_NAME = "default_robot"

def backup_file(file_path: str):
    path = Path(file_path)
    file_name = os.path.splitext(os.path.basename(file_path))[0]
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = Path(BACKUP_DIR) / f"{file_name}-{timestamp}.py"
    path.rename(backup_path)
    print(f"Backup created: {backup_path}")

def make_commander_method(funcs, output_path):
    for func_name, func_info in funcs.items():
        params = func_info["params"]
        with open(output_path, "a", encoding="utf-8") as f:
            f.write(f"\n    def {func_name}(self")

            # 파라미터 작성
            for param, attr in params.items():
                if "default" in attr:
                    default_value = repr(attr["default"])
                    f.write(f", {param}={default_value}")
                else:
                    f.write(f", {param}")

            f.write("):\n")
            f.write(f'        topic = "{func_name}"\n')
            f.write(f'        value = {{}}\n')
            for param in params.keys():
                f.write(f'        value["{param}"] = {param}\n')
            f.write(f'        self.send_command(topic=topic, value=value)\n')

def extract_functions(file_path: str):
    path = Path(file_path)
    source = path.read_text(encoding="utf-8")
    tree = ast.parse(source)

    functions = {}

    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            func_name = node.name

            # 내부용 함수(_로 시작)는 스킵
            if func_name.startswith("_"):
                continue

            params = {}
            for arg in node.args.args:
                if arg.arg == "self":
                    continue
                params[arg.arg] = {}

            defaults = node.args.defaults
            if defaults:
                offset = len(params) - len(defaults)
                for i, default in enumerate(defaults):
                    arg_name = list(params.keys())[i + offset]
                    try:
                        value = ast.literal_eval(default)
                    except Exception:
                        value = None
                    params[arg_name]["default"] = value

            functions[func_name] = {
                "params": params,
                "docstring": ast.get_docstring(node) or ""
            }

    return functions

def build_robot_commander(path: str, robot_name: str, output_path: str) -> None:
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)
    if not os.path.exists(BACKUP_DIR):
        os.makedirs(BACKUP_DIR)

    if os.path.exists(output_path):
        backup_file(output_path)
        
    with open(output_path, "w", encoding="utf-8") as f:
        f.write('"""\nThis file is auto-generated by robot_commander_builder.py\nYou should move this file to the gerri/operator/your_robot_directory\n"""\n\n')
        f.write(SCRIPT_HEADER)
        f.write(f"class {robot_name}Commander:\n")
        f.write(CLASS_INIT)
        f.write(SEND_COMMAND_METHOD)

    print(extract_functions(path))

def main():
    if len(sys.argv) < 2:
        print("Usage: python robot_commander_builder.py <robot_sub_controller.py>")
        sys.exit(1)

    target_file = sys.argv[1]
    path = Path(target_file)
    

    ROBOT_NAME = sys.argv[2] if len(sys.argv) >=3 else "default_robot"

    output_path = OUTPUT_DIR + f"{ROBOT_NAME}_commander.py"

    if not path.exists():
        print(f"File not found: {path}")
        sys.exit(1)

    print(f"Target file: {path.resolve()}")
    build_robot_commander(path.resolve(), ROBOT_NAME, output_path)
    functions = extract_functions(path.resolve())
    make_commander_method(functions, output_path)

if __name__ == "__main__":
    main()
